= Usine Logicielle

Nous mettons en place l'Usine Logicielle pour industrialiser nos développements et notamment accélérer les temps de mises en prod en suivant une démarche de Continuous Delivery : tout commit sur un dépôt GIT d'une application déclenche la construction des binaires de l'application suivi du déploiement de l'application.

Pour ce faire, l'Usine Logicielle fournit des outils pour automatiser la construction des binaires ainsi que des environnements de déploiement.

== Outillage

L'Outillage mis en place permet :

* La gestion des sources des applications
* La construction des binaires de l'application et l'exécution des tests unitaires (via Jenkins)
* L'archivage des binaires (dans Nexus)
* L'analyse qualité des sources (via SonarQube)

=== Gestion des Sources

Les sources sont hébergées dans une Organisation Github https://github.com/SofteamOuest-Opus[dédiée].

Les sources d'une application sont gérées dans un dépôt GIT.

=== Jenkins

==== Configuration Jenkins

De manière à simplifier au maximum la mise en place de l'Usine Logicielle, le serveur Jenkins est configuré automatiquement.

La configuration concerne notamment :

* Les comptes utilisateurs
* Les secrets (mot de passe nexus, token sonarqube)
* Les fichiers de configuration (Gradle, SSH)
* L'import d'organisations GitHub
* L'import de plugins (exemple : JIRA)

==== Jobs Jenkins

De manière à uniformiser nos jobs Jenkins, nous les implémentons via des Jenkinsfile.

Nous implémentons différents types de Jobs, notamment :

* Des Jobs de BUILD pour construire les binaires des applications
* Des Jobs de RELEASE pour figer les versions des applications
* Des Jobs de RUN pour déployer les applications

==== Job de BUILD

Le Job de BUILD d'une application permet de :

* Construire l'image Docker de l'application (en version SNAPSHOT)
* Déclencher un Job de Déploiement

En fin de BUILD, sur la branche develop, l'application est déployée sur le cluster, dans un environnement de DEV.

==== Job de RELEASE

Le Job de RELEASE d'une application permet de :

* Construire l'image Docker de l'application en version RELEASE
* Construire les jars de l'application en version RELEASE
* Déployer les jars de l'application sur le nexus

Le job de RELEASE d'un Chart prend en paramètre :

* La version de la RELEASE
* La prochaine version de développement

==== Job de RELEASE d'un Chart

Un Chart Helm est un package de déploiement d'une application dans Kubernetes.

Le dépôt Charts centralise :

* Les packages Helm (appelés Charts) de toutes les applications.
* Les RELEASES des charts : une RELEASE d'un chart est une archive TGZ.

Le job de RELEASE d'un Chart prend en paramètre la version de la RELEASE et génère l'archive TGZ.

==== Job de RUN

Le Job de RUN permet de déployer une application sur le cluster.

C'est un Job paramétrable qui prend en paramètre :

* Le nom de l'application à déployer
* Le tag de l'image Docker à déployer
* La version du package Helm à utiliser pour le déploiement
* L'environnement de déploiement (dev, prod)

==== Job de FULL-RUN

Le Job de FULL-RUN permet de déployer toutes les applications.

Le Job prend les même paramètres que le Job de RUN (pour chaque application à déployer).

Si le tag de l'image Docker d'une application n'est pas défini, l'application n'est pas déployée.

=== Nexus

Nous utilisons https://nexus.k8.wildwidewest.xyz/[Nexus] pour archiver les images Docker.

Les accès au serveur Nexus sont authentifiés par login, password.

=== SonarQube

Nous utilisons https://sonarqube.k8.wildwidewest.xyz/[SonarQube] pour analyser la qualité du code développé.

Les accès au serveur SonarQube sont authentifiés par token.

=== JIRA

Nous utilisons https://wildwidewest.atlassian.net[JIRA] pour suivre le développement du Projet.

== Environnements

=== DEV, RE7, PROD

L'environnement de DEV permet de tester la dernière version SNAPSHOT des applications.

L'environnement de RE7 permet de tester une version RELEASE avant Mise en Prod.

L'environnement de PROD correspond à l'environnement utilisé.

De manière à isoler les applications des différents environnements, chaque environnement est matérialisé par un namespace dans le cluster Kubernetes.

=== Accès aux Applications

Le nom de l'environnement apparaît dans l'URL de l'application.

Si le nom de l'application est mon application,

* Si le nom de l''environnement est PROD, l'URL d'accès est https://monapplication.k8.wildwidewest.xyz
* Sinon (le nom de l'environnement est XXX), l'URL d'accès est https://monapplication-XXX.k8.wildwidewest.xyz

=== Persistance des Données

La persistance des données est obtenue par mise en place de volumes persistants (PV) NFS. Chaque PV est associé à un disque NFS.

=== Centralisation des Logs

La centralisation des Logs permet d'analyser via une IHM unique les logs de toutes les applications.

Pour simplifier la mise en place, les applications partagent un même format de Logs.

=== Monitoring

Le monitoring permet de monitorer l'état du cluster Kubernetes ainsi que l'état des PODs.

=== Tolérance aux Pannes

La tolérance aux pannes se situ à deux niveaux, les pannes
* Des Applications
* Du cluster

==== Pannes des applications

La gestion des pannes des applications est gérée par Kubernetes.

Pour y arriver, Kubernetes appelle https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/[les lignes de vie des applications].

* Chaque application déployée doit donc définir ses lignes de vie.

==== Pannes du Cluster

La gestion des pannes du cluster est gérée par une installation multi-maîtres :

* Pour être tolérant à une panne, il faut 3 maîtres
* Pour être tolérant à deux pannes, il faut 5 maîtres